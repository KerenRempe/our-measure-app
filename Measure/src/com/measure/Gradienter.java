package com.measure;import com.measure.view.GradienterView;import android.hardware.SensorListener;import android.hardware.SensorManager;import android.os.Bundle;import android.app.Activity;import android.view.Menu;@SuppressWarnings("deprecation")public class Gradienter extends Activity {	int k = 90; // 灵敏度	GradienterView mv;	// 真机	SensorManager mySensorManager;	// 测试时	// SensorManagerSimulator mySensorManager;	@Override	protected void onCreate(Bundle savedInstanceState) {		super.onCreate(savedInstanceState);		setContentView(R.layout.gradienter);		mv = (GradienterView) findViewById(R.id.gradienterView);		mySensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);// 真机	}	private final SensorListener mSensorLisener = new SensorListener() {		@Override		public void onAccuracyChanged(int sensor, int accuracy) {		}		public boolean isContain(int x, int y) {// 判断点是否在圆内			int tempx = (int) (x + mv.zhongBitmap2.getWidth() / 2.0);			int tempy = (int) (y + mv.zhongBitmap2.getWidth() / 2.0);			int ox = (int) (mv.zhong1_X + mv.zhongBitmap1.getWidth() / 2.0);			int oy = (int) (mv.zhong1_X + mv.zhongBitmap1.getWidth() / 2.0);			if (Math.sqrt((tempx - ox) * (tempx - ox) + (tempy - oy)					* (tempy - oy)) + mv.zhongBitmap2.getWidth()/2 > (mv.zhongBitmap1.getWidth() / 2.0 - mv.zhongBitmap2					.getWidth() / 2.0)) {				// 不在圆内				return false;			} else {				// 在圆内时				return true;			}		}		@Override		public void onSensorChanged(int sensor, float[] values) {			if (sensor == SensorManager.SENSOR_ORIENTATION) {				double pitch = values[SensorManager.DATA_Y];				double roll = values[SensorManager.DATA_Z];				int x = 0;				int y = 0;// 临时变量，算中间水泡坐标时用				// 气泡不在边缘时				if (Math.abs(roll) <= k) {					mv.shang2_X = mv.shang1_X // 上面的							+ (int) (((mv.shangBitmap1.getWidth() - mv.shangBitmap2									.getWidth()) / 2.0) * (1 - roll / k));					x = mv.zhong1_X // 中间的							+ (int) (((mv.zhongBitmap1.getWidth() - mv.zhongBitmap2									.getWidth()) / 2.0) * (1 - roll / k));				}				// 气泡在边缘				else if (roll > k) {					mv.shang2_X = mv.shang1_X;					x = mv.zhong1_X;				} else {					mv.shang2_X = mv.shang1_X + mv.shangBitmap1.getWidth()							- mv.shangBitmap2.getWidth();					x = mv.zhong1_X + mv.zhongBitmap1.getWidth()							- mv.zhongBitmap2.getWidth();				}				// 开始调整y 的值				if (Math.abs(pitch) <= k) {					mv.zuo2_Y = mv.zuo1_Y // 左面的							+ (int) (((mv.zuoBitmap1.getHeight() - mv.zuoBitmap2									.getHeight()) / 2.0) * (1 + pitch / k));					y = mv.zhong1_Y + // 中间的							(int) (((mv.zhongBitmap1.getHeight() - mv.zhongBitmap2									.getHeight()) / 2.0) * (1 + pitch / k));				} else if (pitch > k) {					mv.zuo2_Y = mv.zuo1_Y + mv.zuoBitmap1.getHeight()							- mv.zuoBitmap2.getHeight();					y = mv.zhong1_Y + mv.zhongBitmap1.getHeight()							- mv.zhongBitmap2.getHeight();				} else {					mv.zuo2_Y = mv.zuo1_Y;					y = mv.zhong1_Y;				}				if (isContain(x, y)) {// 中间的水泡在圆内才改变坐标					mv.zhong2_X = x;					mv.zhong2_Y = y;				}else{									}				mv.postInvalidate();// 重绘MainView			}		}	};	@Override	protected void onResume() { // 添加监听		mySensorManager.registerListener(mSensorLisener,				SensorManager.SENSOR_ORIENTATION);		super.onResume();	}	@Override	protected void onPause() { // 取消监听		mySensorManager.unregisterListener(mSensorLisener);		super.onPause();	}	}