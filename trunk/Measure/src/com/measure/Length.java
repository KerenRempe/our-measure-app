package com.measure;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.os.Bundle;import android.os.Handler;import android.app.Activity;import android.util.Log;import android.view.Menu;import android.view.MotionEvent;import android.view.SurfaceView;import android.view.View;import android.view.View.OnClickListener;import android.view.View.OnTouchListener;import android.widget.Button;import android.widget.TextView;public class Length extends Activity implements SensorEventListener {	private SensorManager sensorManager;	private Sensor sensor;	private TextView tv1;	private Button bt;	private float acceleration0[] = new float[3];  //记录一个两个时间点，前一个时间点的加速度	private float acceleration1[] = new float[3];	//记录一个两个时间点，前二个时间点的加速度	private float acceleration_o[] = new float[3];	//记录重力加速度 在那轴上的分加速度	private float acceleration_avg[] = new float[3];//记录一个两个时间点，前一个时间点的平均加速度	private float speed[] = new float[3];				private float distance[] = new float[3];		//三轴的位移	boolean start = false;	boolean start_ori = true;	private SurfaceView sv;	long startTime;	private String TAG = "Zdistance";	@Override	public void onCreate(Bundle savedInstanceState) {		super.onCreate(savedInstanceState);		setContentView(R.layout.length);		tv1 = (TextView) findViewById(R.id.textView1);		bt = (Button) findViewById(R.id.button1);		// 1、得到sensorManager对象		sensorManager = (SensorManager) this.getSystemService(SENSOR_SERVICE);		// 2、得到sensor		sensor = sensorManager				.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION);		// 3、得到感应事件监听，通过注册实现	}	public void init() {		for (int i = 0; i < 3; i++) {			acceleration0[i] = 0;			acceleration1[i] = 0;			acceleration_o[i] = 0;			acceleration_avg[i] = 0;			speed[i] = 0;			distance[i] = 0;		}	}	@Override	protected void onPause() {		// TODO Auto-generated method stub		super.onPause();		sensorManager.unregisterListener(this);	}	@Override	protected void onResume() {		// TODO Auto-generated method stub		super.onResume();		sensorManager.registerListener(this, sensor,				sensorManager.SENSOR_DELAY_FASTEST);		bt.setOnTouchListener(new OnTouchListener() {			@Override			public boolean onTouch(View v, MotionEvent event) {				if (event.getAction() == MotionEvent.ACTION_UP) {					start = false;					start_ori = true;					Log.d("test", "cansal button ---> cancel");					Log.i(TAG, "thread destory");					float total_distance = (float) Math							.sqrt((distance[0] * distance[0])									+ (distance[1] * distance[1])									+ (distance[2] * distance[2]));										float temp=(float)1000000000000000000.0;					Log.i(TAG, "total_distance:" + (total_distance /temp));					// total_distance=(float) (total_distance -					// time_count*9.81);					// Log.i(TAG,"9.81_distance:"+time_count*9.81);					Log.i(TAG, "distance0:" + distance[0]/temp);					Log.i(TAG, "distance1:" + distance[1]/temp);					Log.i(TAG, "distance2:" + distance[2]/temp);					tv1.setText("haha" + total_distance/temp);				}				if (event.getAction() == MotionEvent.ACTION_DOWN) {					init();					startTime = System.nanoTime() ;					start = true;				}				return false;			}		});	}	@Override	public void onAccuracyChanged(Sensor arg0, int arg1) {		// TODO Auto-generated method stub	}	@Override	public void onSensorChanged(SensorEvent event) {		// TODO Auto-generated method stub		// alpha is calculated as t / (t + dT)		// with t, the low-pass filter's time-constant		// and dT, the event delivery rate				if (start) {						long time1 = System.nanoTime() ;			Log.i("time1", "time1:" + time1);			long time = time1-startTime ;			startTime = (long) time1;			Log.i(TAG, "time:" + time);												for (int i = 0; i < 3; i++) {				//				if(event.values[i]-acceleration_o[i]<0.08 && event.values[i]-acceleration_o[i]>-0.08){//					//Log.i(TAG, "acceleration"+i+"still!!");//				}				//else{					acceleration1[i] = event.values[i];					acceleration_avg[i] = (acceleration0[i] + acceleration1[i]) / 2;					distance[i] = (float) (distance[i] + speed[i] * time + (time						* time * acceleration_avg[i]) / 2);					speed[i] = speed[i] + (acceleration_avg[i] * time);					acceleration0[i] = acceleration1[i];													Log.i(TAG, "AC      "+i+":"+acceleration1[i]);					Log.i(TAG, "distance" + i + ": " + distance[i]);					Log.i(TAG, "speed   " + i + ": " + speed[i]);					Log.i(TAG,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");				}			//}						Log.i(TAG,"****************************************");		}	}}